

<!DOCTYPE html>
<html >
  <head>
    <meta charset="UTF-8">


    <title>Falling Gestures</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0">


        <style>
        html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}table{border-collapse:collapse;border-spacing:0}

      body {
  height: 100vh;
  background: #252627;
  overflow: hidden;
  width: 100%;
  display: -webkit-box;
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-align: stretch;
  -webkit-align-items: stretch;
      -ms-flex-align: stretch;
          align-items: stretch;
  -webkit-box-orient: vertical;
  -webkit-box-direction: normal;
  -webkit-flex-direction: column;
      -ms-flex-direction: column;
          flex-direction: column;
  color: #eee;
  font-family: monospace;
  font-size: 5vh;
  position: relative;
  -ms-touch-action: none;
      touch-action: none;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

main {
  -webkit-box-flex: 1;
  -webkit-flex: 1;
      -ms-flex: 1;
          flex: 1;
  display: -webkit-box;
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: vertical;
  -webkit-box-direction: normal;
  -webkit-flex-direction: column;
      -ms-flex-direction: column;
          flex-direction: column;
  -webkit-box-align: center;
  -webkit-align-items: center;
      -ms-flex-align: center;
          align-items: center;
  -webkit-box-pack: center;
  -webkit-justify-content: center;
      -ms-flex-pack: center;
          justify-content: center;
}
main p {
  font-size: 1rem;
  text-align: center;
  margin-top: 5vh;
  padding: 0 2rem;
  max-width: 30rem;
  line-height: 1.4;
}

header,
footer {
  height: 5vh;
  line-height: 5vh;
  font-size: 3vh;
  background: #aa6657;
  text-align: right;
  text-transform: uppercase;
  padding: 0 2.5vh;
  overflow: hidden;
  overflow-x: auto;
  max-width: 100%;
}

footer {
  display: -webkit-box;
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-pack: justify;
  -webkit-justify-content: space-between;
      -ms-flex-pack: justify;
          justify-content: space-between;
}
footer ul {
  display: -webkit-box;
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: reverse;
  -webkit-flex-direction: row-reverse;
      -ms-flex-direction: row-reverse;
          flex-direction: row-reverse;
}
footer ul .misses {
  padding: .5vh;
  -webkit-transition: all .225s ease-out;
  transition: all .225s ease-out;
}
footer ul .misses.missed {
  opacity: .4;
  -webkit-transform: rotate(-45deg);
          transform: rotate(-45deg);
}

main > div {
  position: absolute;
  top: 5vh;
  left: 0;
  text-transform: uppercase;
  -webkit-perspective: 300px;
          perspective: 300px;
  -webkit-transition: opacity .7s ease-in;
  transition: opacity .7s ease-in;
  font-size: 10vh;
}
main > div.popped {
  opacity: 0;
}
main > div.popped > span {
  -webkit-animation-play-state: paused;
          animation-play-state: paused;
}
main > div.popped > span b {
  opacity: 0;
}
main > div.missed {
  opacity: 0;
}
main > div.missed > span {
  -webkit-animation-play-state: paused;
          animation-play-state: paused;
}
main > div > span {
  position: absolute;
  display: block;
  -webkit-animation: waver 2s infinite alternate ease-in-out;
          animation: waver 2s infinite alternate ease-in-out;
  -webkit-perspective: 300px;
          perspective: 300px;
}
main > div > span b {
  display: block;
  padding: 2.5vh;
  -webkit-transition: opacity .25s linear;
  transition: opacity .25s linear;
}

@-webkit-keyframes waver {
  100% {
    -webkit-transform: translate3d(6vw, 0, 0);
            transform: translate3d(6vw, 0, 0);
  }
}

@keyframes waver {
  100% {
    -webkit-transform: translate3d(6vw, 0, 0);
            transform: translate3d(6vw, 0, 0);
  }
}
#game-over {
  opacity: 0;
  pointer-events: none;
  -webkit-transition: opacity .75s ease-out;
  transition: opacity .75s ease-out;
  background: rgba(0, 0, 0, 0.75);
  position: absolute;
  top: 5vh;
  right: 0;
  bottom: 5vh;
  left: 0;
  width: 100%;
  display: -webkit-box;
  display: -webkit-flex;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-pack: center;
  -webkit-justify-content: center;
      -ms-flex-pack: center;
          justify-content: center;
  -webkit-box-align: center;
  -webkit-align-items: center;
      -ms-flex-align: center;
          align-items: center;
  -webkit-box-orient: vertical;
  -webkit-box-direction: normal;
  -webkit-flex-direction: column;
      -ms-flex-direction: column;
          flex-direction: column;
  text-transform: uppercase;
}
#game-over.indeed {
  opacity: 1;
  pointer-events: auto;
}

button {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  border-radius: 0;
  border: 0.3rem solid #eee;
  color: #eee;
  font-size: 3vh;
  padding: 1.5vh 2vh;
  background: transparent;
  margin-top: 5vh;
  font-family: monospace;
}
button:hover {
  border-color: #aa6657;
}

    </style>




  </head>

  <body translate="no" >

    <header></header>
<main id="main"></main>
<footer>
  <ul>
    <li class="misses">+</li>
    <li class="misses">+</li>
    <li class="misses">+</li>
    <li class="misses">+</li>
    <li class="misses">+</li>
    <li class="misses">+</li>
  </ul>
  <div id="score">0</div>
</footer>
<div id="game-over">
  <p>Game Over</p>
</div>

    <script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/61811/web-animations-next-2.2.0.min.js'></script>

        <script>
      loadGame();


function loadGame() {
  var button = document.createElement('button');
  button.textContent = 'Start Game';
  var main = document.getElementById('main');
  main.appendChild(button);
  var rules = document.createElement('p');
  rules.textContent = 'Arrows will fall... swipe in the correct direction to knock them away before they hit the ground';
  main.appendChild(rules);
  button.addEventListener('click', function startIt(e) {
    main.textContent = '';
    playGame();
  });
}

function playGame(replay) {
  var LETTERS = ['←','↑','→','↓',];
  var animations = {};
  var gameOn = true;
  var timeOffset = 1200; //interval between letters starting, will be faster over time
  var DURATION = 5000;
  var main = document.getElementById('main');
  var header = document.querySelector('header');
  var scoreElement = document.getElementById('score');
  var score = parseFloat(scoreElement.textContent);
  var rate = 1;
  var RATE_INTERVAL = .05; //playbackRate will increase by .05 for each letter... so after 20 letters, the rate of falling will be 2x what it was at the start
  var misses = 0;
  var activeGestures = {
    pointer: {},
    touch: {},
    mouse: undefined
  }

  LETTERS.forEach(function(l) {
    animations[l] = [];
  });

  //Create a letter element and setup its falling animation, add the animation to the active animation array, and setup an onfinish handler that will represent a miss.
  function create() {
    var idx = Math.floor(Math.random() * LETTERS.length);
    var x = (Math.random() * 75) + 'vw';
    var container = document.createElement('div');
    var letter = document.createElement('span');
    var letterText = document.createElement('b');
    letterText.textContent = LETTERS[idx];
    letter.appendChild(letterText);
    container.appendChild(letter);
    main.appendChild(container);
    var animation = container.animate([
      {transform: 'translate3d('+x+',-5vh,0)'},
      {transform: 'translate3d('+x+',77.5vh,0)'}
    ], {
      duration: DURATION,
      easing: 'linear',
      fill: 'both'
    });

    animations[LETTERS[idx]].splice(0, 0, {animation: animation, element: container});
    rate = rate + RATE_INTERVAL;
    animation.playbackRate = rate;

    //If an animation finishes, we will consider that as a miss, so we will remove it from the active animations array and increment our miss count
    animation.onfinish = function(e) {
      var target = container;
      var char = target.textContent;

      animations[char].pop();
      target.classList.add('missed');
      handleMisses();
    }
  }

  //When a miss is registered, check if we have reached the max number of misses
  function handleMisses() {
    misses++;
    var missedMarker = document.querySelector('.misses:not(.missed)');
    if (missedMarker) {
      missedMarker.classList.add('missed');
    } else {
      gameOver();
    }
  }

  //End game and show screen
  function gameOver() {
    gameOn = false;
    clearInterval(cleanupInterval);
    getAllAnimations().forEach(function(anim) {
      anim.pause();
    });

    //Could use Web Animations API here, but showing how you can use a mix of Web Animations API and CSS transistions
    document.getElementById('game-over').classList.add('indeed');
  }

  //Periodically remove missed elements, and lower the interval between falling elements
  var cleanupInterval = setInterval(function() {
    timeOffset = timeOffset * 4 / 5;
    cleanup();
  }, 20000);
  function cleanup() {
    [].slice.call(main.querySelectorAll('.missed')).forEach(function(missed) {
      main.removeChild(missed);
    });
  }

  //Firefox 48 supports document.getAnimations as per latest spec, Chrome 52 and polyfill use older spec
  function getAllAnimations() {
    if (document.getAnimations) {
      return document.getAnimations();
    } else if (document.timeline && document.timeline.getAnimations) {
      return document.timeline.getAnimations();
    }
    return [];
  }
  function addScore() {
    score++;
    scoreElement.textContent = score;
  }

  //start the letters falling... create the element+animation, and setup timeout for next letter to start
  function setupNextLetter() {
    if (gameOn) {
      create();
      setTimeout(function() {
        setupNextLetter();
      }, timeOffset);
    }
  }
  setupNextLetter();




  //handle gestures
  //On gesture, see if it matches an active animating (falling) arrow. If so, pop it from active array, pause it (to keep it from triggering "finish" logic), and add an animation on inner element with random 3d rotations that look like the arrow is being kicked away to the distance. Also update score.
  if (window.PointerEventXX) {
    // document.body.addEventListener('pointerdown', onPointerDown);
    // document.body.addEventListener('pointerup', onPointerUp);
  } else {
    document.body.addEventListener('mousedown', onMouseDown);
    document.body.addEventListener('mouseup', onMouseUp);

    document.body.addEventListener('touchstart', onTouchStart);
    //document.body.addEventListener('touchmove', function(e) { e.preventDefault(); });
    document.body.addEventListener('touchend', onTouchEnd);
  }
  function onMouseDown(e) {
    activeGestures.mouse = {
      x: e.pageX,
      y: e.pageY
    }
  }
  function onMouseUp(e) {
    determineDirection(activeGestures.mouse, {
      x: e.pageX,
      y: e.pageY
    });
  }
  function onTouchStart(e) {
    e.preventDefault();
    [].slice.call(e.changedTouches).forEach(function(changedTouch) {
      activeGestures.touch[changedTouch.identifier] = {
        x: changedTouch.pageX,
        y: changedTouch.pageY
      }
    });
  }
  function onTouchEnd(e) {
    [].slice.call(e.changedTouches).forEach(function(changedTouch) {
      determineDirection(activeGestures.touch[changedTouch.identifier],{
        x: changedTouch.pageX,
        y: changedTouch.pageY
      });
      delete activeGestures.touch[changedTouch.identifier];
    });
  }

  function determineDirection(start, end) {
    var x = end.x - start.x;
    var y = end.y - start.y;

    if (isHorizontal(x, y)) {
      checkCorrectGesture(isPositive(start.x, end.x) ? '→' : '←');
    } else {
      checkCorrectGesture(isPositive(start.y, end.y) ? '↓' : '↑');
    }
  }

  function isHorizontal(x, y) {
    return Math.abs(x) > Math.abs(y)
  }
  function isPositive(start, end) {
    return end > start;
  }

  function isCorrectGesture(char) {
    return (animations[char] && animations[char].length);
  }
  function checkCorrectGesture(char) {
    if (isCorrectGesture(char)) {
      handleCorrectGesture(char);
    }
  }
  function handleCorrectGesture(char) {
    var popped = animations[char].pop();
    popped.animation.pause();
    var target = popped.element.querySelector('b');
    var degs = [(Math.random() * 1000)-500,(Math.random() * 1000)-500,(Math.random() * 2000)-1000];
    target.animate([
      {transform: 'scale(1) rotateX(0deg) rotateY(0deg) rotateZ(0deg)',opacity:1},
      {transform: 'scale(0) rotateX('+degs[0]+'deg) rotateY('+degs[1]+'deg) rotateZ('+degs[2]+'deg)', opacity: 0}
    ], {
      duration: Math.random() * 500 + 850,
      easing: 'ease-out',
      fill: 'both'
    });
    addScore();
    header.textContent += char;
  }
}
      //# sourceURL=pen.js
    </script>




  </body>
</html>

